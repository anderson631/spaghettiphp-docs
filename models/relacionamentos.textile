p(highlight). Os relacionamentos entre modelos são uma das características mais poderosas do Spaghetti*. Através deles, é possível mapear as associações entre tabelas, tornando mais fácil o trabalho com dados relacionados.

A necessidade de relacionamentos é suficientemente óbvia, e naturalmente definida. Por exemplo, uma postagem em um blog pertence a uma categoria, enquanto esse mesmo post possui vários comentários. Através dessa definição, é possível acessar registros relacionados entre si, retornando-os em apenas uma consulta.

h2. Tipos de Relacionamentos

Até a versão atual, o Spaghetti* trabalha com 3 tipos diferentes de associações: um para um, um para muitos e muitos para um.

|_. Tipo de Relacionamento |_. Relacionamento |_. Exemplos |
|_. hasOne | Um para um | Um usuário possui um perfil |
|_. hasMany | Um para muitos | Um usuário possui vários posts |
|_. belongsTo | Muitos para um | Um usuário pertence a um grupo de usuários |

Para que os relacionamentos funcionem corretamente é preciso que, em uma das duas tabelas, exista um campo de chave estrangeira. Suponha que exista um modelo @Posts@ e um modelo @Usuarios@, e que vários posts pertençam a um usuário. Nesse caso, é necessário que na tabela @posts@ exista um campo @users_id@ para servir como chave estrangeira.

h3. @hasOne@

Uma associação @hasOne@ existe quando um registro pode ter *apenas um* registro correspondente na tabela relacionada. Esse tipo de relacionamento acontece, principalmente, entre tabelas de usuários e tabelas de perfis.

Para definir o relacionamento um para um em um modelo, é preciso definir a variável @hasOne@, com um array contendo todos os outros modelos relacionados:

pre. class Users extends AppModel {
    public $hasOne = array("Profiles");
}

p(note). **Nota**: Para relacionamentos @hasOne@, uma das tabelas deve ter a chave estrangeira correspondente. Em nosso caso, @Profiles@ deveria possuir o campo @users_id@.

Através desse relacionamento, é possível retornar todas as informações de um usuário, com apenas uma chamada ao método @Users::findAll()@, por exemplo.

pre. $this->Users->findAll();

Através da consulta acima, é retornado um array com a seguinte estrutura:

pre. Array
(
    [0] => Array
        (
            [id] => 1
            [name] => admin,
            [password] => spaghettiphp
            [profiles] => Array
                (
                    [id] => 1
                    [users_id] => 1
                    [realname] => Administrador do Site
                )
        )
    [1] => Array
        (
            [id] => 2
            [name] => root,
            [password] => root
            [profiles] => Array
                (
                    [id] => 2
                    [users_id] => 2
                    [realname] => Super Usuário
                )
        )
    [2] => Array
        (
            [id] => 3
            [name] => user
            [password] => 123456
            [profiles] => Array
                (
                    [id] => 3
                    [users_id] => 3
                    [realname] => Usuário Comum
                )
        )
)

h3. @hasMany@

Um relacionamento um para muitos, assim como seu inverso, é um dos mais comuns. Ele acontece quando um registro em determinada tabela possui mais de um registro correspondente em outra tabela. Por exemplo, um usuário pode ter vários posts, ou um post pode ter vários comentários.

Para definir um relacionamento um para muitos, é preciso declarar a variável @hasMany@ no modelo de dados.

pre. class Users extends AppModel {
    public $hasMany = array("Posts");
}

Assim como em @hasOne@, também é possível acessar os registros correspondentes através de métodos como @Model::findAll()@. Entretanto, por padrão o Spaghetti* retorna apenas os dados de relacionamentos @belongsTo@ e @hasOne@, para evitar a sobrecarga de seu banco de dados. Para retornar registros de @hasMany@, é necessário passar o parâmetro @$recursion@:

pre. $this->Users->findAll(array(), null, null, 1);

O array retornado é apenas ligeiramente diferente do retornado por @hasOne@:

pre. Array
(
    [0] => Array
        (
            [id] => 1
            [name] => admin,
            [password] => spaghettiphp
            [posts] => Array
                (
                    [0] => Array
                        (
                            [id] => 1
                            [users_id] => 1
                            [title] => Meu Primeiro Post
                        )
                )
        )
    [1] => Array
        (
            [id] => 2
            [name] => root,
            [password] => root
            [posts] => Array
                (
                    [0] => Array
                        (
                            [id] => 2
                            [users_id] => 2
                            [title] => Esse também é meu primeiro post
                        )
                    [1] => Array
                        (
                            [id] => 3
                            [users_id] => 2
                            [title] => Mais um post meu =P
                        )
                )
        )
)

p(note). **Nota**: nesse caso, a chave estrangeira deve estar presente apenas no modelo relacionado, e não naquele em que se descreve o relacionamento.

h3. @belongsTo@

Relacionamentos muitos para um são exatamento o inverso de relacionamentos um para muitos. Embora não seja necessário, acontece em qualquer lado oposto de um relacionamento @hasMany@. Acontece quando um post pertence a um usuário, ou quando um post pertence a uma categoria.

Para descrever um relacionamento muitos para um, é necessário definir a variável @belongsTo@ no modelo desejado:

pre. class Comments extends AppModel {
    public $belongsTo = array("Posts");
}

p(note). **Nota**: em relacionamentos @belongsTo@, a chave estrangeira deve estar presente apenas na tabela em que se descreve o relacionamento, e não no modelo relacionado, justamente o contrário de relacionamentos @hasMany@

h2. Definindo Recursão

O Spaghetti* define uma recursão padrão para seus modelos, para que você não precise se preocupar com sobrecarga em seu servidor de banco de dados. Entretanto, muitas vezes é necessário definir uma recursão maior, ou mesmo menor. É possível modificar essa recursão padrão através da variável @$recursion@, definida na classe dos modelos de dados.

pre. class Users extends AppModel {
    public $recursion = 1;
}

Caso esse número de recursões seja compartilhado entre todos os modelos de sua aplicação, você pode criar o modelo @AppModel@ em @app/models/app.php@, e definir a mesma variável.

pre. class AppModel extends Model { // aqui estendemos Model em vez de AppModel!
    public $recursion = 1;
}

O valor da recursão pode variar dependendo de sua necessidade. Os valores possíves variam desde -1 até qualquer número positivo.

|_. Recursão |_. Dados retornados |
|_. -1 | Nenhum registro relacionado é retornado. |
|_. 0 | São retornados apenas os registros relacionados diretamente por @hasOne@ e @belongsTo@ |
|_. 1 | São retornados todos os registros relacionados diretamente pelo modelo, incluindo @hasMany@ |
|_. n > 2 | Além dos registros relacionados diretamente, retorna __n__ níveis de recursão |

Não é necessário definir níveis de recursão maiores do que o necessário. Isso pode diminuir a velocidade de sua aplicação, assim como causar sobrecarga em seu servidor. Use com responsabilidade!

h2. Definindo atributos para relacionamentos

O Spaghetti*, além de lhe prover várias convenções, também consegue trabalhar muito bem sobre configuração. Você pode ter várias opções para definir melhor seus relacionamentos.

Para definir as opções de relacionamentos, é necessário modificar um pouco como os relacionamentos são definidos. Em vez de apenas um array numerado, é necessário nomeá-lo, da seguinte maneira:

pre. public $hasMany = array("assocName" => array("option" => "value"));

==
<ul>
<li><code>className</code> determina o nome da classe do modelo relacionado. Assim, é possível definir qualquer nome para a associação, sem que a associação pare de funcionar.</li>
<li><code>foreignKey</code> determina o nome da chave estrangeira. Como o Spaghetti* ainda não conta com singularização/pluralização, você pode definir manualmente um nome no singular, ou mesmo qualquer outro nome, para a chave.</li>
<li><code>conditions</code> é um array ou string de condições. Somente os registros que obedeçam a essa condição serão adicionados �  associação.</li>
</ul>
==