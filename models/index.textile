Os _models_ do Spaghetti* são os responsáveis por todas as tarefas de banco de dados. É através deles que você criará, atualizará, apagará e buscará registros das tabelas de seu banco de dados. Tudo isso sem escrever uma única linha de SQL, já que o Spaghetti* abstrai tudo isso em um formato simples de _arrays_, puramente em PHP, como você verá em breve.

h2(#models/criando). Criando _Models_

Dentro da estrutura de diretórios do Spaghetti*, os _models_ se encontram em @/app/models/@. É lá onde ficarão todos os modelos de sua aplicação que você criar. O nome de arquivo de um modelo deve seguir a convenção @nome_do_modelo.php@. Por exemplo, se você criar um modelo @UserPermissions@, por exemplo, o nome do respectivo arquivo deverá ser @user_permissions.php@.

Inicialmente, um modelo é apenas uma classe vazia, que estende de @AppModel@:

pre. class Users extends AppModel {
}

Quando seu modelo herda de @AppModel@, que por sua vez herda de @Model@, você terá ao seu dispor toda as funcionalidades necessárias para lidar com o banco de dados. Além disso, o Spaghetti* já relaciona por padrão um modelo com sua respectiva tabela no banco de dados, que deve ter o mesmo nome do modelo. Caso a tabela não exista, o Spaghetti* gerará um erro. No nosso caso, para que nosso _model_ funcione, você precisará ter uma tabela chamada @users@.

Caso você tenha um modelo que tenha sua respectiva tabela no banco de dados com um nome diferente, ou mesmo que não possua uma tabela, é possível sobrescrever o comportamento do Spaghetti* através do atributo @table@.

pre. class Users extends AppModel {
    public $table = 'users_table';
}

Caso nosso modelo fosse usado apenas para validação de dados, e não possuísse uma tabela no banco de dados, @Users::$table@ deveria ser definido como @false@, e então o Spaghetti* ignoraria a relação do modelo com o banco de dados.

h2. Buscando Registros

Para a busca de registros, @Model@ conta com dois métodos: @first()@ e @all()@. @Model::first()@ é o responsável por buscar apenas o primeiro registro que atende a uma determinada condição, enquanto @Model::all()@ retorna uma lista com todos eles.

Ambos os métodos recebem apenas um parâmetro, um _array_ contendo todas as opções da busca. Esses parâmetros são os responsáveis pela definição de condições, ordem dos registros, limite, recursão e campos a serem retornados.

Para definir as condições de uma busca, usamos @conditions@ como item de nosso array de opções.

pre. $options = array(
    "conditions" => "id = 1"
);
$this->Users->first($options);

Com a busca acima, retornaremos o primeiro registro que corresponda à condição @id = 1@. Entretanto, dessa maneira estamos passando uma condição literal em SQL para o Spaghetti*, que não escapará valores e deixará sua aplicação vulnerável a ataques de _SQL injection_. Para que isso não aconteça, devemos passar condições de uma maneira que o Spaghetti* possa interpretar, escapando valores perigosos.

pre. $options = array(
    "conditions" => array(
        "id" => 1
    )
);
$this->Users->first($options);

p(note). *Nota*: embora seja possível passar condições literalmente para o Spaghetti*, essa prática é desencorajada, pois pode abrir brechas de segurança em sua aplicação. Caso você deseje fazer isso, lembre-se de fazer o escape de valores antes de enviá-los para a consulta. Nunca considere dados vindos do usuário como seguros!

Além de condições simples como essa, o Spaghetti* também suporta outros tipos de condições mais complexas. Por exemplo:

pre. $options = array(
    "conditions" => array(
        "title LIKE" => "%Spaghetti%"
    )
);

p(note). Você pode ver como usar outros tipos de condições em "Condições":/docs/developer-guide/models/condicoes.

Para definir o limite de registros que uma consulta deve devolver, usamos o item @limit@, que pode receber apenas o número de registros a retornar ou a quantidade de registros a partir de um índice.

pre. $options = array(
    "limit" => 20
);
$this->Users->all($options);

p(note). *Nota*: se @Model::first()@ receber @limit@ como parâmetro, ele não terá efeito algum, pois sempre será sobrescrito por @1@.

Para definir a ordem dos registros a serem retornados, usamos o item @order@. Assim como definimos @ORDER BY@ em SQL, essa opção também pode receber vários campos a ordernar separados por vírgula.

pre. $options = array(
    "order" => "created DESC"
);
$this->Users->all($options);

Para definir os campos a serem retornados pela consulta, usamos o item @fields@. Por padrão, o Spaghetti* passa uma lista com todos os campos da tabela por essa opção, mas podemos sobrescrevê-la para retornar apenas os campos necessários. Esse parâmetro pode ser passado como uma _string_ contendo os campos separados por vírgulas ou como um _array_.

pre. $options = array(
    "fields" => array("id", "name", "password")
);
$this->Users->all($options);

O retorno desses métodos é um _array_ comum, que pode ser iterado normalmente através de @for@ ou @foreach@. A estrutura desse _array_ é semelhante à seguinte:

pre.. $this->Users->all($options);
// retornará
Array
(
    [0] => Array
        (
            [id] => 1
            [name] => admin,
            [password] => spaghettiphp
        )
    [1] => Array
        (
            [id] => 2
            [name] => root,
            [password] => root
        )
    [2] => Array
        (
            [id] => 3
            [name] => user
            [password] => 123456
        )
)

$this->Users->first($options);
// retornará
Array
(
    [id] => 1,
    [username] => admin
    [password] => spaghettiphp
)

h2. Salvando Registros

O salvamento de registros é sempre algo complicado. Primeiro é necessário saber se um registro existe, para depois podermos decidir se ele deve ser inserido ou se deve ser apenas atualizado. Com o Spaghetti*, você se preocupa apenas em enviar os dados, e o resto é gerenciado pelo _framework_.

Para o salvamento de registros, usa-se apenas o método @save()@, passando como parâmetros apenas os dados a serem salvos em formato de um _array_ semelhante ao seguinte:

pre. $data = array(
    "id" => 1,
    "username" => "admin",
    "password" => "spaghettiphp"
);

Chamando @Model::save()@, o retorno será @true@ caso o registro tenha sido salvo, ou @false@ caso tenha havido algum erro no processo.

pre. $this->Users->save($data); // => true

O Spaghetti* sabe se um registro existe ou não a partir do valor da chave primária do registro que você está salvando. Caso esse valor da chave primária seja @null@ ou não exista no banco de dados, um novo registro é criado. Caso contrário, o registro existente é atualizado. Por padrão, o nome da chave primária no Spaghetti* é o mesmo valor da chave primária no banco de dados. Se o seu banco de dados não tem um campo definido como chave primária, é necessário definí-la manualmente no seu _model_ através de @Model::primaryKey@:

pre. class Users extends AppModel {
    public $primaryKey = "id_user";
}

@Model::save()@ usa, inicialmente, @$data[$this->primaryKey]@ (que se transformaria em @$data["id"]@, por padrão) como o valor da chave primária do registro a ser salvo. Caso ele não esteja definido ou seja @null@, o Spaghetti* usará o valor presente em @Model::id@. No exemplo abaixo, o registro com @id = 2@ é atualizado:

pre. $this->Users->id = 2;
$this->Users->save(array(
    "password" => "654321"
));

p(note). *Nota*: quando você estiver salvando vários registros do mesmo _model_, como em um _loop_, lembre-se de definir @id = null@ para que os registros não sejam sobrescritos.

Quando um novo registro é criado, @Model@ também altera o valor de @Model::id@ para o id da última inserção. Assim, não é necessário fazer uma chamada a outro método para recuperar esse valor.

pre. $this->Users->save(array(
    "username" => "spaghetti_framework",
    "password" => "abcdef"
));
echo $this->Users->id; // => 4

h2. Campos _created_ e _modified_

Muitas vezes é necessário manter registro das datas de criação e modificação de um registro. Para que você não precise explicitamente definir valor para esses campos, o Spaghetti* faz isso para você.

Para que esse comportamento seja usado, é necessário ter os campos @created@ ou @modied@ definidos como @DATETIME@ em sua tabela. O campo @created@ é definido apenas uma vez, na criação do registro, e somente caso não tenha um valor já definido em @$data@. Já o campo @modified@ é redefinido a cada salvamento do registro, também somente caso não esteja definido em @$data@.

h4. Prevenção contra SQL Injection

Também somos preocupados com segurança. Por isso, toda e qualquer string usada como valor é passada pelo método @Model::escape()@, escapando qualquer caracter que possa ser perigoso caso esteja em uma consulta SQL. E não se preocupe com @magic_quotes@, o modelo já faz a verificação e elimina barras quando necessário.

Caso você precise fazer consultas de maneira manual, ou precise escapar qualquer string dentro da aplicação, basta usar essa mesma função.

pre. $this->Users->escape("String 'potencialmente' perigosa");
// Retorna "String \'potencialmente\' perigosa"

h3. @saveAll(@ array $data @)@

|_. array $data | Dados a serem salvos |

Caso você precise salvar vários registros de uma só vez, o Spaghetti* lhe dá a opção do método @Model::saveAll()@. Ele dispõe de todas as funcionalidades de @Model::save()@, com exceção do parâmetro recebido. Esse parâmetro deve ser um array com a seguinte estrutura:

pre. Array
(
    [0] => Array
        (
            [id] => 1
            [name] => admin,
            [password] => spaghettiphp
        )
    [1] => Array
        (
            [id] => 2
            [name] => root,
            [password] => root
        )
    [2] => Array
        (
            [id] => 3
            [name] => user
            [password] => 123456
        )
)

h2. Apagando Registros

h3. @delete(@ integer $id @)@

|_. integer $id | ID do registro a ser apagado |

@Model::delete()@ apaga apenas um registro com ID @$id@ da tabela. Como ele é limitado a apenas um registro, mesmo que existam vários IDs iguais, apenas o primeiro será apagado.

h3. @deleteAll(@ mixed $conditions, mixed $order, integer $limit @)@

|_. mixed $conditions | Array ou string contendo as condições para que um registro seja apagado |
|_. mixed $order | Array ou string que define a ordenação dos registros a serem apagados |
|_. integer $limit | Limite de registros apagados |

@Model::deleteAll()@ faz a remoção de vários registros de uma única vez, apagando registros que obedeçam � s condições @$conditions@, ordenados por @$order@ e limitados por @$limit@.

Esse método é útil quando é necessário apagar vários registros, que não obedeçam apenas a IDs, como usuários não aprovados ou mensagens de spam.

pre. $this->Users->deleteAll(array("approved" => false));

h2. __Joins__ ou relacionamentos

O Spaghetti* suporta três tipos de relacionamentos, ou __joins__: um para um, um para muitos e muitos para um. "Saiba Mais":/docs/relacionamentos-entre-models.

h2. Métodos Personalizados

Os modelos de dados do Spaghetti* são poderosos o suficiente para prover todas as funcionalidades básicas que você precisa para desenvolver sua aplicação sem se preocupar com detalhes como escrever SQL. Entretanto, você pode precisar de um pouco mais.

Não esqueça que as classes de modelo podem ser estendidas: basta você adicionar métodos e propriedades! Qualquer função repetitiva relacionada a banco de dados deve ser escrita aqui. Depois, você poderá usá-la em qualquer __controller__ que use esse modelo. DRY(Don't Repeat Yourself), tudo definido em um lugar só!

pre. class Posts extends AppModel {
    public function findLastPosts() {
        return $this->findAll(array("created <" => "curdate()"), array("created" => "DESC"));
    }
}

O método @Posts::findLastPost()@, depois de definido, pode ser utilizado normalmente dentro de um controller.

pre. $this->Posts->findLastPosts();