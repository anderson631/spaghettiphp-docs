p(highlight). A autenticação de usuários é algo comum a maioria das aplicações hoje em dia. Pensando nisso, o Spaghetti* já traz o componente @AuthComponent@ em seu núcleo, pronto para ser usado!

O uso do @AuthComponent@ é extremamente simples, e sua configuração requer apenas algumas linhas. Em poucos minutos você já tem um sistema de autenticação de usuários simples funcionando.

Para usar o @AuthComponent@, primeiro é preciso ativá-lo nos __controllers__ em que você deseja usá-lo. Como geralmente a autenticação se aplica a vários __controllers__ dentro da aplicação, é recomendável definí-lo diretamente no @AppController@.

pre. class AppController extends Controller {
	public $components = array("Auth");
}

Assim que o componente é ativado, ele se torna disponível dentro do __controller__ através de @$this->AuthComponent@. Assim, podemos começar a utilizar seus métodos.

h2. Criando o modelo de usuários

O @AuthComponent@ já espera que você possua um modelo @Users@, e sua respectiva tabela com, no mínimo, os campos @username@ e @password@. Caso seja necessário mudar essas opções, você precisa definir isso dentro do __controller__, no callback @beforeFilter()@.

pre. class AppController extends Controller {
	public $components = array("Auth");
	public function beforeFilter() {
		// definindo o modelo de usuários
		$this->AuthComponent->userModel = "AppUsers";
		// definindo os campos de nome de usuário e senha
		$this->AuthComponent->fields = array(
			"username" => "name",
			"password" => "passphrase"
		);
	}
}

h2. Ações de Login e Logout

Para que possamos fazer a autenticação do usuário, é necessário criarmos as __actions__ para login e logout. @AuthComponent@, por padrão, redireciona o usuário para @/users/login@ e @/users/logout@. Então, em um __controller__ @Users@, devemos criar essas duas ações.

pre. class UsersController extends AppController {
	public function login() {
		$this->AuthComponent->login();
	}
	public function logout() {
		$this->AuthComponent->logout();
	}
}

Assim que essas duas ações são chamadas, é necessário disparar os métodos da classe @AuthComponent@, @login()@ e @logout()@. São essas duas funções que farão a verificação, autenticação e desautenticação do usuário. Embora essas funções cuidem da parte difícil, você ainda precisa criar a __view__ de login.

pre. <?php echo $form->create() ?>
<?php echo $form->input("username") // deve ser o mesmo nome definido em AuthComponent::fields["username"] ?>
<?php echo $form->input("password") // deve ser o mesmo nome definido em AuthComponent::fields["password"] ?>
<?php echo $form->close("Entrar") ?>

h2. Checando o usuário e permitindo acesso

Para que possamos checar se o usuário está autenticado, precisamos adicionar uma chamada ao método @AuthComponent::check()@ no callback @beforeFilter()@ do __controller__. Esse método checa se o usuário está autenticado, e faz o redirecionamento para a tela de login, quando necessário.

pre. public function beforeFilter() {
	$this->AuthComponent->check();
}

Mesmo assim, o usuário ainda tem acesso a todos os recursos da aplicação, por padrão o componente permite acesso a toda a aplicação. As permissões podem ser definidas aos níveis de prefixo, __controller__ e __action__, e são definidas através dos métodos @allow@ e @deny@.

pre. public function beforeFilter() {
	$this->AuthComponent->deny("*"); // nega acesso a toda página que não possuir um prefixo
	$this->AuthComponent->allow(array("controller" => "users", "action" => "register"));
	$this->AuthComponent->allow(array("prefix" => "public"));
	$this->AuthComponent->check();
}

Às vezes, também é preciso verificar se um usuário está aprovado para efetuar login, ou se ele pertence a determinado grupo de usuários. Nesse caso, usa-se o atributo @userScope@, que provê condições adicionais para a verificação.

pre. public function beforeFilter() {
	$this->AuthComponent->deny("*");
	$this->AuthComponent->userScope = array("approved" => true, "group <>" => "banned");
	$this->AuthComponent->check();
}

p(note). *Nota:* Quando adicionar seções bloqueadas ou autorizadas de sua aplicação, a chamada para o método @$this->AuthComponent->check()@ deve estar sempre depois.

h2. Recuperando dados do usuário

Dentro da aplicação, também pode se fazer necessária a recuperação de dados do usuário, para poder usá-los na identificação de registros. Sempre que for necessária a utilização de alguma informação do usuário na aplicação, usa-se o método @AuthComponent::user()@, passando como parâmetro o campo que se deseja retornar.

pre. $this->AuthComponent->user("id"); // retornará o id do usuário

h2. Encriptando Senhas

Não é seguro, e nem considerado uma boa prática, manter as senhas dos usuários sem nenhum tipo de criptografia. O @AuthComponent@ usa __hashs__ MD5, que e um tipo de criptografia de apenas uma via, para armazenar senhas. Assim, toda senha em seu banco de dados deve seguir esse padrão.

Para que você não precise usar diretamente a função @md5()@, o @AuthComponent@ já possui o método @hashPasswords()@. Ele recebe um parâmetro provindo de @Controller::data@, e criptografa o campo definido como campo de senha por @AuthComponent->fields["password"]@.

h2. Variáveis para personalização

Caso alguma das configurações padrão do @AuthComponent@ seja diferente das suas necessidades, é possível personalizá-lo de forma que lhe atenda melhor. As variáveis configuráveis são:

|_. Variável |_. Função |
| loginAction | URL para a qual o usuário será redirecionado quando não estiver autenticado |
| loginRedirect | URL para qual o usuário será redirecionado quando efetuar login |
| logoutRedirect | URL para a qual o usuário será redirecionado quando efetuar logout |